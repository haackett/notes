use rusty_euler::collect_line_from_grid;
use rusty_euler::Fibonacci;
use rusty_euler::GridDirection;
use rusty_euler::Primes;
use rusty_euler::TriangleNumbers;
use rusty_euler::num_divisors;
use rusty_euler::Collatz;

use std::iter;

use rug::Integer;
use rug::ops::Pow;
use rug::Assign;
use itertools::Itertools;
use num::integer::lcm;

fn main() {
    //println!("Problem 2:\n\t{:?}", p_2());
    //println!("Problem 5:\n\t{:?}", p_5());
    //println!("Problem 6:\n\t{:?}", p_6());
    //println!("Problem 7:\n\t{:?}", p_7());
    //println!("Problem 8:\n\t{:?}", p_8());
    //println!("Problem 9:\n\t{:?}", p_9());
    //println!("Problem 10:\n\t{:?}", p_10());
    //println!("Problem 11:\n\t{:?}", p_11());
    //println!("Problem 12:\n\t{:?}", p_12());
    //println!("Problem 13:\n\t{:?}", p_13());
    //println!("Problem 14:\n\t{:?}", p_14());
    //println!("Problem 15:\n\t{:?}",p_15());
    println!("Problem 57:\n\t{:?}",p_57());
}

/// Each new term in the Fibonacci sequence is generated by adding the previous
/// two terms. By starting with 1 and 2, the first 10 terms will be:
///
/// $$
/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
/// $$
///
/// By considering the terms in the Fibonacci sequence whose values do not
/// exceed four million, find the sum of the even-valued terms.
fn p_2() -> i64 {
    Fibonacci::new()
        .skip(1)
        .take_while(|n| n < &4_000_000)
        .filter(|n| n % 2 == 0)
        .sum()
}

/// 2520 is the smallest number that can be divided by each of the numbers from
/// 1 to 10 without any remainder.
///
/// What is the smallest positive number that is evenly divisible by all of the
/// numbers from 1 to 20?
///
///
/// *Note, this is just really another of way of asking what the lcm(0..=20) is.*
fn p_5() -> i64 {
    (1..=20).fold(1, lcm)
}

/*
/// Test if all integers 1..=n divide x
fn evenly_divisable_for_range(x: i64, n: i64) -> bool {
    (1..=n)
        .map(|a| x % a == 0)
        .all(|b| b)
}
*/

/// <p>The sum of the squares of the first ten natural numbers is,</p>
///
/// $$
/// 1^2 + 2^2 + ... + 10^2 = 385
/// $$
///
/// <p>The square of the sum of the first ten natural numbers is,</p>
///
/// $$
/// (1 + 2 + ... + 10)^2 = 55^2 = 3025
/// $$
///
/// <p>Hence the difference between the sum of the squares of the first ten
/// natural numbers and the square of the sum is $3025 - 385 = 2640$.</p>
/// <p>Find the difference between the sum of the squares of the first one
/// hundred natural numbers and the square of the sum.</p>
fn p_6() -> i64 {
    let sum_of_squares = (100 * (100 + 1) * (2 * (100) + 1)) / 6;
    let sum = (100 * (100 + 1)) / 2;
    let square_of_sum = i64::pow(sum, 2);
    square_of_sum - sum_of_squares
}

/// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
/// that the 6th prime is 13.
///
/// What is the 10,001st prime number?
fn p_7() -> i64 {
    Primes::new().take(10001).last().unwrap()
}

/// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
///
/// 73167176531330624919225119674426574742355349194934
/// 96983520312774506326239578318016984801869478851843
/// 85861560789112949495459501737958331952853208805511
/// 12540698747158523863050715693290963295227443043557
/// 66896648950445244523161731856403098711121722383113
/// 62229893423380308135336276614282806444486645238749
/// 30358907296290491560440772390713810515859307960866
/// 70172427121883998797908792274921901699720888093776
/// 65727333001053367881220235421809751254540594752243
/// 52584907711670556013604839586446706324415722155397
/// 53697817977846174064955149290862569321978468622482
/// 83972241375657056057490261407972968652414535100474
/// 82166370484403199890008895243450658541227588666881
/// 16427171479924442928230863465674813919123162824586
/// 17866458359124566529476545682848912883142607690042
/// 24219022671055626321111109370544217506941658960408
/// 07198403850962455444362981230987879927244284909188
/// 84580156166097919133875499200524063689912560717606
/// 05886116467109405077541002256983155200055935729725
/// 71636269561882670428252483600823257530420752963450
///
/// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What
/// is the value of this product?
fn p_8() -> u64 {
    const INPUT: &str = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
    let digits = INPUT 
        .chars()
        .map(|c| c.to_digit(10).unwrap() as u64)
        .collect::<Vec<u64>>();

    digits
        .windows(13)
        .map(|window| window.iter().product())
        .max()
        .unwrap()
}

/// <p>A Pythagorean triplet is a set of three natural numbers, <var>a</var> &lt;
/// <var>b</var> &lt; <var>c</var>, for which,</p>
/// <div class="center"> <var>a</var><sup>2</sup> + <var>b</var><sup>2</sup> =
/// <var>c</var><sup>2</sup></div>
/// <p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.
/// </p>
/// <p>There exists exactly one Pythagorean triplet for which <var>a</var> +
/// <var>b</var> + <var>c</var> = 1000.<br />Find the product <var>abc</var>.</p>
fn p_9() -> u32 {
    for a in 1..1000_u32 {
        for b in 1..1000_u32 {
            for c in 1..1000_u32 {
                if a + b + c == 1000 && a.pow(2) + b.pow(2) == c.pow(2) {
                    return a * b * c;
                }
            }
        }
    }
    0
}

/// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
///
/// Find the sum of all the primes below two million.
fn p_10() -> i64 {
    Primes::new().take_while(|p| p < &2_000_000).sum()
}

/// In the 20×20 grid below, four numbers along a diagonal line have been marked
/// in red.
///
/// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
/// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
/// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
/// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
/// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
/// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
/// 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
/// 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
/// 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
/// 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
/// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
/// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
/// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
/// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
/// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
/// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
/// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
/// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
/// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
/// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
///
/// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
///
/// What is the greatest product of four adjacent numbers in the same direction
/// (up, down, left, right, or diagonally) in the 20×20 grid?
fn p_11() -> i64 {
    const INPUT: &str = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
                         49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
                         81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
                         52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
                         22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
                         24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
                         32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
                         67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
                         24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
                         21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
                         78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
                         16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
                         86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
                         19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
                         04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
                         88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
                         04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
                         20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
                         20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
                         01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";
    let length = 4;

    let grid = INPUT 
        .split('\n')
        .map(|s| {
            s.split_whitespace()
                .map(|c| c.parse::<i64>().unwrap())
                .collect::<Vec<i64>>()
        })
        .collect::<Vec<Vec<i64>>>();

    let mut max = 0;

    for (m, row) in grid.iter().enumerate() {
        for (n, _) in row.iter().enumerate() {
            let up: i64 = collect_line_from_grid(&grid, m, n, length, GridDirection::up)
                .unwrap_or_else(|| vec![0])
                .iter()
                .product();
            let down: i64 = collect_line_from_grid(&grid, m, n, length, GridDirection::down)
                .unwrap_or_else(|| vec![0])
                .iter()
                .product();
            let left: i64 = collect_line_from_grid(&grid, m, n, length, GridDirection::left)
                .unwrap_or_else(|| vec![0])
                .iter()
                .product();
            let right: i64 = collect_line_from_grid(&grid, m, n, length, GridDirection::right)
                .unwrap_or_else(|| vec![0])
                .iter()
                .product();
            let upper_diagonal: i64 =
                collect_line_from_grid(&grid, m, n, length, GridDirection::upper_diagonal)
                    .unwrap_or_else(|| vec![0])
                    .iter()
                    .product();
            let lower_diagonal: i64 =
                collect_line_from_grid(&grid, m, n, length, GridDirection::lower_diagonal)
                    .unwrap_or_else(|| vec![0])
                    .iter()
                    .product();
            let upper_antidiagonal: i64 =
                collect_line_from_grid(&grid, m, n, length, GridDirection::upper_antidiagonal)
                    .unwrap_or_else(|| vec![0])
                    .iter()
                    .product();
            let lower_antidiagonal: i64 =
                collect_line_from_grid(&grid, m, n, length, GridDirection::lower_antidiagonal)
                    .unwrap_or_else(|| vec![0])
                    .iter()
                    .product();
            let local_max = *[
                up,
                down,
                left,
                right,
                upper_diagonal,
                lower_diagonal,
                upper_antidiagonal,
                lower_antidiagonal,
            ]
            .iter()
            .max()
            .unwrap_or(&0);

            if local_max > max {
                max = local_max;
            }
        }
    }
    max
}

/// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
/// 
/// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
/// 
/// Let us list the factors of the first seven triangle numbers:
/// 
///      1: 1
///      3: 1,3
///      6: 1,2,3,6
///     10: 1,2,5,10
///     15: 1,3,5,15
///     21: 1,3,7,21
///     28: 1,2,4,7,14,28
/// 
/// We can see that 28 is the first triangle number to have over five divisors.
/// 
/// What is the value of the first triangle number to have over five hundred divisors?
fn p_12() -> u64{
    TriangleNumbers::default().take_while(|n| {

        let cnt_divisors = num_divisors(n);
        println!("{}  {}", n, cnt_divisors);

        cnt_divisors < 500
    }).last().unwrap()
}

/// The following iterative sequence is defined for the set of positive integers:
/// 
/// n → n/2 (n is even)
/// n → 3n + 1 (n is odd)
/// 
/// Using the rule above and starting with 13, we generate the following 
/// sequence:
///
/// 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
/// 
/// It can be seen that this sequence (starting at 13 and finishing at 1) 
/// contains 10 terms. Although it has not been proved yet (Collatz Problem), it
/// is thought that all starting numbers finish at 1.
/// 
/// Which starting number, under one million, produces the longest chain?
/// 
/// NOTE: Once the chain starts the terms are allowed to go above one million.
fn p_13() -> usize {
    let mut collatz_cache = vec![0];
    (1..1_000_000).
        enumerate()
        .map(|(i,n)| {
            println!("{}",i);
            let sequence = Collatz::from(n)
                .take_while(|a| collatz_cache.get(*a as usize) == None)
                .collect::<Vec<u64>>();
            let last = *sequence.last().unwrap() as usize;
                if collatz_cache.get(last).is_some() {
                    let seq_length = sequence.len() - 1 + collatz_cache.get(last).unwrap();
                    collatz_cache.push(seq_length);
                    seq_length
                }
                else {
                    let seq_length = sequence.len();
                    collatz_cache.push(seq_length);
                    seq_length
                }
        })
        .max()
        .unwrap() 
}




/// Starting in the top left corner of a 2×2 grid, and only being able to move 
/// to the right and down, there are exactly 6 routes to the bottom right corner.
///
/// How many such routes are there through a 20×20 grid?
fn p_14() -> u128 {
    // need to take 40 moves total from 20 down and 20 right
    // how many ways to choose which are down?
    // pick 20 of the 40 total moves to be down.
    // so 40 choose 20
    //
    //(1..=(20+20)).product::<u128>() / ((1..=20).product::<u128>() * (1..(40-20)).product::<u128>())

    (21..=40).product::<u128>() / (1..=20).product::<u128>()
}



/// 215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
///
/// What is the sum of the digits of the number 21000?
fn p_15() -> Integer {
    Integer::from(2).pow(1000).to_string_radix(10).chars().map(|c| c.to_digit(10).unwrap()).sum()
}

/// Iterator to get the numerators of a continued fraction given
/// a sequence definied by [a_0;a_1,...,a_n] where this is the simple continued
/// fraction.
///
/// h_n = a_nh_{n-1} + h_{n-2}          h_{-1} = 1 h_{-2}=0
/// k_n = a_nk_{n-1} + k_{n-2}          k_{-1} = 0 k_{-2}=1
struct ContinuedFractionComponent<F> {
    a_iter : F,
    last : Integer,
    second_last : Integer,
}

impl<F> ContinuedFractionComponent<F> 
where
    F : Iterator<Item = Integer>
{
    fn h(a : F) -> Self
    {
        ContinuedFractionComponent {
            a_iter : a,
            last : Integer::from(1),
            second_last : Integer::ZERO,
        }
    }
    
    fn k(a : F) -> Self
    {
        ContinuedFractionComponent {
            a_iter : a,
            last : Integer::ZERO,
            second_last : Integer::from(1),
        }
    }
}

impl<F> Iterator for ContinuedFractionComponent<F> 
where 
    F : Iterator<Item = Integer>,
{
    type Item = Integer;

    fn next(&mut self) -> Option<Self::Item> {
        // blegh
        let swap = self.last.clone();
        self.last = self.a_iter.next()? * &self.last + &self.second_last;
        self.second_last = swap;
        Some(self.last.clone())
    }

}


struct Sqrt2 {
    first : bool,
}

impl Iterator for Sqrt2 {
    type Item = Integer;

    fn next(&mut self) -> Option<Self::Item> {
        if self.first {
            self.first = false;
            return Some(Integer::from(1))
        }
        Some(Integer::from(2))
    }

}

/// <p>It is possible to show that the square root of two can be expressed as an infinite continued fraction.</p>
/// <p class="center">$\sqrt 2 =1+ \frac 1 {2+ \frac 1 {2 +\frac 1 {2+ \dots}}}$</p>
/// <p>By expanding this for the first four iterations, we get:</p>
/// <p>$1 + \frac 1 2 = \frac  32 = 1.5$<br />
/// $1 + \frac 1 {2 + \frac 1 2} = \frac 7 5 = 1.4$<br />
/// $1 + \frac 1 {2 + \frac 1 {2+\frac 1 2}} = \frac {17}{12} = 1.41666 \dots$<br />
/// $1 + \frac 1 {2 + \frac 1 {2+\frac 1 {2+\frac 1 2}}} = \frac {41}{29} = 1.41379 \dots$<br /></p>
/// <p>The next three expansions are $\frac {99}{70}$, $\frac {239}{169}$, and $\frac {577}{408}$, but the eighth expansion, $\frac {1393}{985}$, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.</p>
/// <p>In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator?</p>
fn p_57() -> usize {
    let sqrt2 = Sqrt2 { first : true };
    let sqrt22 = Sqrt2 { first : true };
    let numerators = ContinuedFractionComponent::h(sqrt2);
    let denominators = ContinuedFractionComponent::k(sqrt22);
    
    // disgusting.
    
    numerators.zip(denominators)
        .take(1000)
        .filter(|(p,q)| {
            p.to_string().chars().count() > q.to_string().chars().count()
        })
        .count()
}


